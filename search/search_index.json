{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Path Planning using Convex Lifting This is a MATLAB toolbox for pathplanning, or finding a path in a continuous environment with obstacles, in two or three dimensions. It uses the novel Convex Lifting method to construct a graph of possible paths in the environment. This toolbox requires MPT and tbxmanager . Installation First, install both dependencies : MPT tbxmanager You may also install the Matlab Optimisation Toolbox to speed up some calculations. To use the tooblox, download the latest release from github and add the toolbox directory to your matlab path, for example by adding add_path( \"/home/... path to the toolbox ../toolbox\" ); to startup.m in your project directory. Before calling any function from this toolbox (or MPT), call mpt_init; Usage Basic Usage % required before using mpt mpt_init; % let obstacles be a column vector of Polyhedron objects % returns a lifting object lifting = Lifting.find(obstacles, LiftOptions.linearDefault()); % choose the method to construct the graph then build it buider = graph .EdgeGraphBuilder(); g = builder.getGraph(lifting.getPartition()); % TODO : make a better API g = corridors.corridor_width(g, obstacles); g = corridors.edge_weigth(g); % find the shortest path found_path = alt_graph.path(g, src, dst); % get information about the path [corridors, path_width, path_length] = corridors.corridor_post_processing(G, found_path, 100 ); Examples More example programs are available in the examples directory as scripts. To run them, simply add the examples to the matlab path. Building This section is relevant for developpers only and not necessary to use the toolbox Toolbox To create a release of the toolbox, run make release Documentation This documentation is built with mkdocs , the following python packages are required: mkdocs pymdown-extensions pygments run mkdocs build to build the html documentation to use with github pages in site/ and mkdocs serve to build and serve on localhost API Documentation Most of the information in this section is also available as doc comments inside the code of the toolbox. It can be acessed with help <name> or doc <name> inside matlab. class Lifting A class to perform a convex lifting and create a partition of the space class LiftOptions A simple structure that holds all the options to create a [Lifting] object class GraphBuilder A class that provides a method to construct a graph class graph Functions to operate on graphs class corridors Functions to manipulate the security corridors class mpc A class to perform MPC computation. Implementation exists but is unstable and undocumented, see +testing for examples.","title":"Home"},{"location":"#path-planning-using-convex-lifting","text":"This is a MATLAB toolbox for pathplanning, or finding a path in a continuous environment with obstacles, in two or three dimensions. It uses the novel Convex Lifting method to construct a graph of possible paths in the environment. This toolbox requires MPT and tbxmanager .","title":"Path Planning using Convex Lifting"},{"location":"#installation","text":"First, install both dependencies : MPT tbxmanager You may also install the Matlab Optimisation Toolbox to speed up some calculations. To use the tooblox, download the latest release from github and add the toolbox directory to your matlab path, for example by adding add_path( \"/home/... path to the toolbox ../toolbox\" ); to startup.m in your project directory. Before calling any function from this toolbox (or MPT), call mpt_init;","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#basic-usage","text":"% required before using mpt mpt_init; % let obstacles be a column vector of Polyhedron objects % returns a lifting object lifting = Lifting.find(obstacles, LiftOptions.linearDefault()); % choose the method to construct the graph then build it buider = graph .EdgeGraphBuilder(); g = builder.getGraph(lifting.getPartition()); % TODO : make a better API g = corridors.corridor_width(g, obstacles); g = corridors.edge_weigth(g); % find the shortest path found_path = alt_graph.path(g, src, dst); % get information about the path [corridors, path_width, path_length] = corridors.corridor_post_processing(G, found_path, 100 );","title":"Basic Usage"},{"location":"#examples","text":"More example programs are available in the examples directory as scripts. To run them, simply add the examples to the matlab path.","title":"Examples"},{"location":"#building","text":"This section is relevant for developpers only and not necessary to use the toolbox","title":"Building"},{"location":"#toolbox","text":"To create a release of the toolbox, run make release","title":"Toolbox"},{"location":"#documentation","text":"This documentation is built with mkdocs , the following python packages are required: mkdocs pymdown-extensions pygments run mkdocs build to build the html documentation to use with github pages in site/ and mkdocs serve to build and serve on localhost","title":"Documentation"},{"location":"#api-documentation","text":"Most of the information in this section is also available as doc comments inside the code of the toolbox. It can be acessed with help <name> or doc <name> inside matlab.","title":"API Documentation"},{"location":"#class-lifting","text":"A class to perform a convex lifting and create a partition of the space","title":"  class  Lifting "},{"location":"#class-liftoptions","text":"A simple structure that holds all the options to create a [Lifting] object","title":"  class  LiftOptions "},{"location":"#class-graphbuilder","text":"A class that provides a method to construct a graph","title":"  class  GraphBuilder "},{"location":"#class-graph","text":"Functions to operate on graphs","title":"  class  graph "},{"location":"#class-corridors","text":"Functions to manipulate the security corridors","title":"  class  corridors "},{"location":"#class-mpc","text":"A class to perform MPC computation. Implementation exists but is unstable and undocumented, see +testing for examples.","title":"  class  mpc "},{"location":"GraphBuilder/","text":"class graph.IGraphBuilder An abstract class for building a Liftgraph from a partition provided by a Lifting . Creating a subclass of this is encouraged if you need to build a graph in a way to supported by the default builders subclass graph.EdgeGraphBuilder A possible graph builder, construct with the default constructor. subclass graph.BarycenterGraphBuilder A possible graph builder, construct with the default constructor. method getGraph Constructs a LiftGraph Usage lift_graph = builder.getGraph( partition ) Parameters lift_graph Returns a LiftGraph partition A column vector of MPT Polyhedron objects, the builder may fail if they are not a partition (every edge must be fully shared between neighbours)","title":"class GraphBuilder"},{"location":"GraphBuilder/#class-graphigraphbuilder","text":"An abstract class for building a Liftgraph from a partition provided by a Lifting . Creating a subclass of this is encouraged if you need to build a graph in a way to supported by the default builders","title":"  class  graph.IGraphBuilder "},{"location":"GraphBuilder/#subclass-graphedgegraphbuilder","text":"A possible graph builder, construct with the default constructor.","title":"  subclass  graph.EdgeGraphBuilder "},{"location":"GraphBuilder/#subclass-graphbarycentergraphbuilder","text":"A possible graph builder, construct with the default constructor.","title":"  subclass  graph.BarycenterGraphBuilder "},{"location":"GraphBuilder/#method-getgraph","text":"Constructs a LiftGraph Usage lift_graph = builder.getGraph( partition ) Parameters lift_graph Returns a LiftGraph partition A column vector of MPT Polyhedron objects, the builder may fail if they are not a partition (every edge must be fully shared between neighbours)","title":" method  getGraph "},{"location":"LiftOptions/","text":"class LiftOptions A data structure that contains options for Lifting.find Every property for this class is public and meant to be read and written directly Properties sdp ( 1 , 1 ) struct = sdpsettings() debug ( 1 , 1 ) logical = false verbose ( 1 , 1 ) logical = false strategy ( 1 , 1 ) string = \"linear\" cluster_count ( 1 , 1 ) uint32 = 5 depth ( 1 , 1 ) uint32 = 0 fallback ( 1 , 1 ) string = \"linear\" min_cvx ( 1 , 1 ) double = 0.001 solver ( 1 , 1 ) string = \"\" sdp An overwrite for the settings used when calling MPT , see MPT / YALMIP documentation debug If this flag is set, functions are allow to show debug information like timing etc..., this also sets debug = true in MPT / YALMIP calls verbose If this flag is set, functions may print extra information, this also sets verbose = true in MPT / YALMIP calls strategy One of \"linear\" , \"convex\" , \"cluster\" . sets the strategy for finding the lifting, \"linear\" is generaly best for less than 60 obstacles, use \"cluster\" for more obstacles, \"convex\" is generally worse than the other options. See Lifting Strategies cluster_count For the \"cluster\" strategy only, how many clusters to use depth For the \"cluster\" strategy only, how deep the tree or recursive call should be fallback What stratgey to use when depth == 0 or when a clustering operation fails min_cvx For the \"convex\" strategy, a minimal convexity requirement, must be strictly greater than 0 solver Which solver to use, must be comatible with the strategy, see YALMIP documentation Methods static method linearDefault Creates a LiftOptions with default (non debug) settings for the \"linear\" strategy Usage options = LiftOptions.linearDefault() static method convexDefault Creates a LiftOptions with default (non debug) settings for the \"convex\" strategy Usage options = LiftOptions.convexDefault() static method clusterDefault Creates a LiftOptions with default (non debug) settings for the \"cluster\" strategy Usage options = LiftOptions.clusterDefault()","title":"class LiftOptions"},{"location":"LiftOptions/#class-liftoptions","text":"A data structure that contains options for Lifting.find Every property for this class is public and meant to be read and written directly","title":"  class  LiftOptions "},{"location":"LiftOptions/#properties","text":"sdp ( 1 , 1 ) struct = sdpsettings() debug ( 1 , 1 ) logical = false verbose ( 1 , 1 ) logical = false strategy ( 1 , 1 ) string = \"linear\" cluster_count ( 1 , 1 ) uint32 = 5 depth ( 1 , 1 ) uint32 = 0 fallback ( 1 , 1 ) string = \"linear\" min_cvx ( 1 , 1 ) double = 0.001 solver ( 1 , 1 ) string = \"\" sdp An overwrite for the settings used when calling MPT , see MPT / YALMIP documentation debug If this flag is set, functions are allow to show debug information like timing etc..., this also sets debug = true in MPT / YALMIP calls verbose If this flag is set, functions may print extra information, this also sets verbose = true in MPT / YALMIP calls strategy One of \"linear\" , \"convex\" , \"cluster\" . sets the strategy for finding the lifting, \"linear\" is generaly best for less than 60 obstacles, use \"cluster\" for more obstacles, \"convex\" is generally worse than the other options. See Lifting Strategies cluster_count For the \"cluster\" strategy only, how many clusters to use depth For the \"cluster\" strategy only, how deep the tree or recursive call should be fallback What stratgey to use when depth == 0 or when a clustering operation fails min_cvx For the \"convex\" strategy, a minimal convexity requirement, must be strictly greater than 0 solver Which solver to use, must be comatible with the strategy, see YALMIP documentation","title":"Properties"},{"location":"LiftOptions/#methods","text":"","title":"Methods"},{"location":"LiftOptions/#static-method-lineardefault","text":"Creates a LiftOptions with default (non debug) settings for the \"linear\" strategy Usage options = LiftOptions.linearDefault()","title":" static method  linearDefault "},{"location":"LiftOptions/#static-method-convexdefault","text":"Creates a LiftOptions with default (non debug) settings for the \"convex\" strategy Usage options = LiftOptions.convexDefault()","title":" static method  convexDefault "},{"location":"LiftOptions/#static-method-clusterdefault","text":"Creates a LiftOptions with default (non debug) settings for the \"cluster\" strategy Usage options = LiftOptions.clusterDefault()","title":" static method  clusterDefault "},{"location":"Lifting/","text":"class Lifting Lifting is an abstract class with methods to create and manipulate a convex lifting. You may create a subclass of Lifting but it will not be accessible through the find constructor static method find This is the main constructor for the Lifting class see LiftOptions for more details. The convex lifting is performed immediatly when this is called but the partition is not generated until it is needed Usage lifting = Lifting.find(obstacles, options) Parameters obstacles A column vector of MPT Polyhedron objects options A LiftOptions object lifting The function returns a Lifting object method getGraph A function to construct a graph from a lifting Usage g = lifting.getGraph(graph_builder, bbox) Parameters graph_builder A IGraphBuilder bbox A bounding box used to create the partition, should be at least the convex hull of the obstacles g A matlab graph abstract method isSuccess This quickly tests wether lifting was successful, if this returns false, displaying the result of getDiagnostic may provide help Usage result = lifting.isSuccess() Parameters result a logical value, true if a lifting wa sucessuflly found abstract method getDiagnostic This returns details on the failure or success of Lifting.find Usage diagnostic = lifting.getDiagnostic() Parameters diagnostic a struct that contains diagnostic data, depends on the lift implementation","title":"class Lifting"},{"location":"Lifting/#class-lifting","text":"Lifting is an abstract class with methods to create and manipulate a convex lifting. You may create a subclass of Lifting but it will not be accessible through the find constructor","title":"  class  Lifting "},{"location":"Lifting/#static-method-find","text":"This is the main constructor for the Lifting class see LiftOptions for more details. The convex lifting is performed immediatly when this is called but the partition is not generated until it is needed Usage lifting = Lifting.find(obstacles, options) Parameters obstacles A column vector of MPT Polyhedron objects options A LiftOptions object lifting The function returns a Lifting object","title":" static method  find "},{"location":"Lifting/#method-getgraph","text":"A function to construct a graph from a lifting Usage g = lifting.getGraph(graph_builder, bbox) Parameters graph_builder A IGraphBuilder bbox A bounding box used to create the partition, should be at least the convex hull of the obstacles g A matlab graph","title":" method getGraph"},{"location":"Lifting/#abstract-method-issuccess","text":"This quickly tests wether lifting was successful, if this returns false, displaying the result of getDiagnostic may provide help Usage result = lifting.isSuccess() Parameters result a logical value, true if a lifting wa sucessuflly found","title":" abstract method isSuccess"},{"location":"Lifting/#abstract-method-getdiagnostic","text":"This returns details on the failure or success of Lifting.find Usage diagnostic = lifting.getDiagnostic() Parameters diagnostic a struct that contains diagnostic data, depends on the lift implementation","title":" abstract method getDiagnostic"},{"location":"corridors/","text":"module corridors Operations related to the safety area around the paths. function edge_weight A default way to calculate edge weights for pathfinding This can be replaced by a user functions, simply set g.Edges.Weight from g.Edges.length and g.Edges.width Usage corridors.edge_weight(g) Parameters g The graph function corridor_post_processing Calculates the actual corridor data once the path is found. Usage [cor, min_width] = corridor_post_processing(G, path , start , target, obstacles, n) Parameters G The graph path The path to calculate corridors on start The start of the path target The end of the path obstacles The obstacles vector n :","title":"module corridors"},{"location":"corridors/#module-corridors","text":"Operations related to the safety area around the paths.","title":" module corridors "},{"location":"corridors/#function-edge_weight","text":"A default way to calculate edge weights for pathfinding This can be replaced by a user functions, simply set g.Edges.Weight from g.Edges.length and g.Edges.width Usage corridors.edge_weight(g) Parameters g The graph","title":" function  edge_weight "},{"location":"corridors/#function-corridor_post_processing","text":"Calculates the actual corridor data once the path is found. Usage [cor, min_width] = corridor_post_processing(G, path , start , target, obstacles, n) Parameters G The graph path The path to calculate corridors on start The start of the path target The end of the path obstacles The obstacles vector n :","title":" function  corridor_post_processing "},{"location":"graph/","text":"module graph Functions on graphs. function path Calculates the shortest path on a graph. Usage path = graph .path(g, start , dest, obstacles, partition ) Parameters g The graph to operate on start A vector, the point to start from dest A Vecotr, the point to end on obstacles The obstacles vector used to create the lifting partition The partition obtained from the lifting path A vector of indices into the graph function path_length Calculates the length of the path Usage length = graph .path_length(g, path , start , dest) Parameters g The graph to operate on path The path from graph.path start The starting point dest The end point","title":"module graph"},{"location":"graph/#module-graph","text":"Functions on graphs.","title":" module graph "},{"location":"graph/#function-path","text":"Calculates the shortest path on a graph. Usage path = graph .path(g, start , dest, obstacles, partition ) Parameters g The graph to operate on start A vector, the point to start from dest A Vecotr, the point to end on obstacles The obstacles vector used to create the lifting partition The partition obtained from the lifting path A vector of indices into the graph","title":" function  path "},{"location":"graph/#function-path_length","text":"Calculates the length of the path Usage length = graph .path_length(g, path , start , dest) Parameters g The graph to operate on path The path from graph.path start The starting point dest The end point","title":" function  path_length "},{"location":"lift/","text":"module lift This modules contains functions to create and operate on a convex lifting function find Find a convex lifting over a set of obstacles, Usage [oa, ob] = lift.find(obstacles) Parameters obstacles An array of Polyhedron of length N . All the elements must be of the same dimension D Return Values The returned values define the found convex lifting, they are such that the lifting function is defined by z(x) = max(oa * x + ob) . oa A matrix with N lines and ' D columns ob A column vector with N lines function max Find the maximum of the convex lifting function in a given space, used internally when tracing the lifting function to place the obstacles above it. Usage max_value = lift.max(oa, ob, space) Parameters oa and ob The values returned by lift.find space Where to look for the maximum, currently a scalar representing the radius of a hypercube Return Values max_value The maximum of the convex lifting","title":"<span class=\"code\"> <span class=\"mod\">module</span> lift </span>"},{"location":"lift/#module-lift","text":"This modules contains functions to create and operate on a convex lifting","title":" module lift "},{"location":"lift/#function-find","text":"Find a convex lifting over a set of obstacles, Usage [oa, ob] = lift.find(obstacles) Parameters obstacles An array of Polyhedron of length N . All the elements must be of the same dimension D Return Values The returned values define the found convex lifting, they are such that the lifting function is defined by z(x) = max(oa * x + ob) . oa A matrix with N lines and ' D columns ob A column vector with N lines","title":" function find "},{"location":"lift/#function-max","text":"Find the maximum of the convex lifting function in a given space, used internally when tracing the lifting function to place the obstacles above it. Usage max_value = lift.max(oa, ob, space) Parameters oa and ob The values returned by lift.find space Where to look for the maximum, currently a scalar representing the radius of a hypercube Return Values max_value The maximum of the convex lifting","title":" function max "}]}