{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Path Planning using Convex Lifting This is a MATLAB toolbox for pathplanning, or finding a path in a continuous environment with obstacles, in two or three dimensions. It uses the novel Convex Lifting method to construct a graph of possible paths in the environment. This toolbox requires MPT and tbxmanager . Installation First, install both dependencies : MPT tbxmanager You may also install the Matlab Optimisation Toolbox to speed up some calculations. To use the tooblox, download the latest release from github and add the toolbox directory to your matlab path, for example by adding add_path( \"/home/... path to the toolbox ../toolbox\" ); to startup.m in your project directory. Before calling any function from this toolbox (or MPT), call mpt_init; Usage Basic Usage % required before using mpt mpt_init; % let obstacles be a column vector of Polyhedron objects % returns a lifting object lifting = Lifting.find(obstacles, LiftOptions.linearDefault()); % choose the method to construct the graph then build it buider = graph .EdgeGraphBuilder(); g = builder.getGraph(lifting.getPartition()); % TODO : make a better API g = corridors.corridor_width(g, obstacles); g = corridors.edge_weigth(g); % find the shortest path found_path = alt_graph.path(g, src, dst); % get information about the path [corridors, path_width, path_length] = corridors.corridor_post_processing(G, found_path, 100 ); Examples More example programs are available in the examples directory as scripts. To run them, simply add the examples to the matlab path. Building This section is relevant for developpers only and not necessary to use the toolbox Toolbox To create a release of the toolbox, run make release Documentation This documentation is built with mkdocs , the following python packages are required: mkdocs pymdown-extensions pygments run mkdocs build to build the html documentation to use with github pages in site/ and mkdocs serve to build and serve on localhost API Documentation Most of the information in this section is also available as doc comments inside the code of the toolbox. It can be acessed with help <name> or doc <name> inside matlab. class Lifting A class to perform a convex lifting and create a partition of the space class LiftOptions A simple structure that holds all the options to create a [Lifting] object","title":"Home"},{"location":"#path-planning-using-convex-lifting","text":"This is a MATLAB toolbox for pathplanning, or finding a path in a continuous environment with obstacles, in two or three dimensions. It uses the novel Convex Lifting method to construct a graph of possible paths in the environment. This toolbox requires MPT and tbxmanager .","title":"Path Planning using Convex Lifting"},{"location":"#installation","text":"First, install both dependencies : MPT tbxmanager You may also install the Matlab Optimisation Toolbox to speed up some calculations. To use the tooblox, download the latest release from github and add the toolbox directory to your matlab path, for example by adding add_path( \"/home/... path to the toolbox ../toolbox\" ); to startup.m in your project directory. Before calling any function from this toolbox (or MPT), call mpt_init;","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#basic-usage","text":"% required before using mpt mpt_init; % let obstacles be a column vector of Polyhedron objects % returns a lifting object lifting = Lifting.find(obstacles, LiftOptions.linearDefault()); % choose the method to construct the graph then build it buider = graph .EdgeGraphBuilder(); g = builder.getGraph(lifting.getPartition()); % TODO : make a better API g = corridors.corridor_width(g, obstacles); g = corridors.edge_weigth(g); % find the shortest path found_path = alt_graph.path(g, src, dst); % get information about the path [corridors, path_width, path_length] = corridors.corridor_post_processing(G, found_path, 100 );","title":"Basic Usage"},{"location":"#examples","text":"More example programs are available in the examples directory as scripts. To run them, simply add the examples to the matlab path.","title":"Examples"},{"location":"#building","text":"This section is relevant for developpers only and not necessary to use the toolbox","title":"Building"},{"location":"#toolbox","text":"To create a release of the toolbox, run make release","title":"Toolbox"},{"location":"#documentation","text":"This documentation is built with mkdocs , the following python packages are required: mkdocs pymdown-extensions pygments run mkdocs build to build the html documentation to use with github pages in site/ and mkdocs serve to build and serve on localhost","title":"Documentation"},{"location":"#api-documentation","text":"Most of the information in this section is also available as doc comments inside the code of the toolbox. It can be acessed with help <name> or doc <name> inside matlab.","title":"API Documentation"},{"location":"#class-lifting","text":"A class to perform a convex lifting and create a partition of the space","title":"  class  Lifting "},{"location":"#class-liftoptions","text":"A simple structure that holds all the options to create a [Lifting] object","title":"  class  LiftOptions "},{"location":"LiftOptions/","text":"class LiftOptions A data structure that contains options for Lifting.find Every property for this class is public and meant to be read and written directly Properties sdp ( 1 , 1 ) struct = sdpsettings() debug ( 1 , 1 ) logical = false verbose ( 1 , 1 ) logical = false strategy ( 1 , 1 ) string = \"linear\" cluster_count ( 1 , 1 ) uint32 = 5 depth ( 1 , 1 ) uint32 = 0 fallback ( 1 , 1 ) string = \"linear\" min_cvx ( 1 , 1 ) double = 0.001 solver ( 1 , 1 ) string = \"\" sdp An overwrite for the settings used when calling MPT , see MPT / YALMIP documentation debug If this flag is set, functions are allow to show debug information like timing etc..., this also sets debug = true in MPT / YALMIP calls verbose If this flag is set, functions may print extra information, this also sets verbose = true in MPT / YALMIP calls strategy One of \"linear\" , \"convex\" , \"cluster\" . sets the strategy for finding the lifting, \"linear\" is generaly best for less than 60 obstacles, use \"cluster\" for more obstacles, \"convex\" is generally worse than the other options. See Lifting Strategies cluster_count For the \"cluster\" strategy only, how many clusters to use depth For the \"cluster\" strategy only, how deep the tree or recursive call should be fallback What stratgey to use when depth == 0 or when a clustering operation fails min_cvx For the \"convex\" strategy, a minimal convexity requirement, must be strictly greater than 0 solver Which solver to use, must be comatible with the strategy, see YALMIP documentation Methods static method linearDefault Creates a LiftOptions with default (non debug) settings for the \"linear\" strategy Usage options = LiftOptions.linearDefault() static method convexDefault Creates a LiftOptions with default (non debug) settings for the \"convex\" strategy Usage options = LiftOptions.convexDefault() static method clusterDefault Creates a LiftOptions with default (non debug) settings for the \"cluster\" strategy Usage options = LiftOptions.clusterDefault()","title":"class LiftOptions"},{"location":"LiftOptions/#class-liftoptions","text":"A data structure that contains options for Lifting.find Every property for this class is public and meant to be read and written directly","title":"  class  LiftOptions "},{"location":"LiftOptions/#properties","text":"sdp ( 1 , 1 ) struct = sdpsettings() debug ( 1 , 1 ) logical = false verbose ( 1 , 1 ) logical = false strategy ( 1 , 1 ) string = \"linear\" cluster_count ( 1 , 1 ) uint32 = 5 depth ( 1 , 1 ) uint32 = 0 fallback ( 1 , 1 ) string = \"linear\" min_cvx ( 1 , 1 ) double = 0.001 solver ( 1 , 1 ) string = \"\" sdp An overwrite for the settings used when calling MPT , see MPT / YALMIP documentation debug If this flag is set, functions are allow to show debug information like timing etc..., this also sets debug = true in MPT / YALMIP calls verbose If this flag is set, functions may print extra information, this also sets verbose = true in MPT / YALMIP calls strategy One of \"linear\" , \"convex\" , \"cluster\" . sets the strategy for finding the lifting, \"linear\" is generaly best for less than 60 obstacles, use \"cluster\" for more obstacles, \"convex\" is generally worse than the other options. See Lifting Strategies cluster_count For the \"cluster\" strategy only, how many clusters to use depth For the \"cluster\" strategy only, how deep the tree or recursive call should be fallback What stratgey to use when depth == 0 or when a clustering operation fails min_cvx For the \"convex\" strategy, a minimal convexity requirement, must be strictly greater than 0 solver Which solver to use, must be comatible with the strategy, see YALMIP documentation","title":"Properties"},{"location":"LiftOptions/#methods","text":"","title":"Methods"},{"location":"LiftOptions/#static-method-lineardefault","text":"Creates a LiftOptions with default (non debug) settings for the \"linear\" strategy Usage options = LiftOptions.linearDefault()","title":" static method  linearDefault "},{"location":"LiftOptions/#static-method-convexdefault","text":"Creates a LiftOptions with default (non debug) settings for the \"convex\" strategy Usage options = LiftOptions.convexDefault()","title":" static method  convexDefault "},{"location":"LiftOptions/#static-method-clusterdefault","text":"Creates a LiftOptions with default (non debug) settings for the \"cluster\" strategy Usage options = LiftOptions.clusterDefault()","title":" static method  clusterDefault "},{"location":"Lifting/","text":"class Lifting Lifting is an abstract class with methods to create and manipulate a convex lifting. You may create a subclass of Lifting but it will not be accessible through the find constructor static method find This is the main constructor for the Lifting class see LiftOptions for more details. The convex lifting is performed immediatly when this is called but the partition is not generated until it is needed Usage lifting = Lifting.find(obstacles, options) Parameters obstacles A column vector of MPT Polyhedron objects options A LiftOptions object lifting The function returns a Lifting object abstract method isSuccess This quickly tests wether lifting was successful, if this returns false, displaying the result of getDiagnostic may provide help Usage result = lifting.isSuccess() Parameters result a logical value, true if a lifting wa sucessuflly found abstract method getDiagnostic This returns details on the failure or success of Lifting.find Usage diagnostic = lifting.getDiagnostic() Parameters diagnostic a struct that contains diagnostic data, depends on the lift implementation","title":"class Lifting"},{"location":"Lifting/#class-lifting","text":"Lifting is an abstract class with methods to create and manipulate a convex lifting. You may create a subclass of Lifting but it will not be accessible through the find constructor","title":"  class  Lifting "},{"location":"Lifting/#static-method-find","text":"This is the main constructor for the Lifting class see LiftOptions for more details. The convex lifting is performed immediatly when this is called but the partition is not generated until it is needed Usage lifting = Lifting.find(obstacles, options) Parameters obstacles A column vector of MPT Polyhedron objects options A LiftOptions object lifting The function returns a Lifting object","title":" static method  find "},{"location":"Lifting/#abstract-method-issuccess","text":"This quickly tests wether lifting was successful, if this returns false, displaying the result of getDiagnostic may provide help Usage result = lifting.isSuccess() Parameters result a logical value, true if a lifting wa sucessuflly found","title":" abstract method isSuccess"},{"location":"Lifting/#abstract-method-getdiagnostic","text":"This returns details on the failure or success of Lifting.find Usage diagnostic = lifting.getDiagnostic() Parameters diagnostic a struct that contains diagnostic data, depends on the lift implementation","title":" abstract method getDiagnostic"},{"location":"graph/","text":"module graph Functions for testing this library. function Causes an error if size(x) is different from shape . *","title":"<span class=\"code\"> <span class=\"mod\">module</span> graph </span>"},{"location":"graph/#module-graph","text":"Functions for testing this library.","title":" module graph "},{"location":"graph/#function","text":"Causes an error if size(x) is different from shape . *","title":" function "},{"location":"lift/","text":"module lift This modules contains functions to create and operate on a convex lifting function find Find a convex lifting over a set of obstacles, Usage [oa, ob] = lift.find(obstacles) Parameters obstacles An array of Polyhedron of length N . All the elements must be of the same dimension D Return Values The returned values define the found convex lifting, they are such that the lifting function is defined by z(x) = max(oa * x + ob) . oa A matrix with N lines and ' D columns ob A column vector with N lines function max Find the maximum of the convex lifting function in a given space, used internally when tracing the lifting function to place the obstacles above it. Usage max_value = lift.max(oa, ob, space) Parameters oa and ob The values returned by lift.find space Where to look for the maximum, currently a scalar representing the radius of a hypercube Return Values max_value The maximum of the convex lifting","title":"<span class=\"code\"> <span class=\"mod\">module</span> lift </span>"},{"location":"lift/#module-lift","text":"This modules contains functions to create and operate on a convex lifting","title":" module lift "},{"location":"lift/#function-find","text":"Find a convex lifting over a set of obstacles, Usage [oa, ob] = lift.find(obstacles) Parameters obstacles An array of Polyhedron of length N . All the elements must be of the same dimension D Return Values The returned values define the found convex lifting, they are such that the lifting function is defined by z(x) = max(oa * x + ob) . oa A matrix with N lines and ' D columns ob A column vector with N lines","title":" function find "},{"location":"lift/#function-max","text":"Find the maximum of the convex lifting function in a given space, used internally when tracing the lifting function to place the obstacles above it. Usage max_value = lift.max(oa, ob, space) Parameters oa and ob The values returned by lift.find space Where to look for the maximum, currently a scalar representing the radius of a hypercube Return Values max_value The maximum of the convex lifting","title":" function max "},{"location":"project/","text":"module project Functions for testing this library. function Causes an error if size(x) is different from shape . *","title":"<span class=\"code\"> <span class=\"mod\">module</span> project </span>"},{"location":"project/#module-project","text":"Functions for testing this library.","title":" module project "},{"location":"project/#function","text":"Causes an error if size(x) is different from shape . *","title":" function "},{"location":"testing/","text":"module testing Functions for testing this library. function Causes an error if size(x) is different from shape . *","title":"<span class=\"code\"> <span class=\"mod\">module</span> testing </span>"},{"location":"testing/#module-testing","text":"Functions for testing this library.","title":" module testing "},{"location":"testing/#function","text":"Causes an error if size(x) is different from shape . *","title":" function "},{"location":"util/","text":"module util This modules contains internal functions that are not meant to be used by the end user. function assert_shape Causes an error if size(x) is different from shape . Usage util.assert_shape(x, shape) function barycenter Usage center = util.barycenter( poly ) Parameters poly Any bounded, non empty Polyhedron of dimension D Return Values center A D dimensional row vector representing the barycenter of poly function box Returns a hypercube of a given radius, potentially stretch vertically Usage poly = util.box(center, radius) poly = util.box(center, radius, z_size) Parameters Calculates the barycenter of a polyhedron : the average of all its vertices. center A row vector of dimension D radius A Scalar, he distance in each dimension from center to the edge of the cube z_size If given, overrides radius for the last dimension Return Values poly A D dimensional hypercube, stretched if z_size is different from radius function is_near_unit Tests wether a vector is nearly colinear to any of the unit vectors of the canonical basis. The exact formula used is N(v/N(v) - u) <= epsilon where v is the tested vector, u the unit vector and N is the euclidian norm. Usage test = util.is_near_unit(vector) test = util.is_near_unit(vector, epsilon) Parameters vector Any row vector epsilon The error margin, defaults to 0.001 function matrix_equals Tests wether two matrixes are equal within a given margin of error test = util.matrix_equals(A, B) test = util.matrix_equals(A, B, epsilon) Parameters A and B Two matrices to test epsilon The margin of error, defaults to 0.001 function read_obj Reads a set of polyhedra from a .obj (blender) file. Usage poly = util.read_obj(file) poly = util.read_obj(file, useHRep) Parameters file The name of a file to load polyhedra from, relative to the cwd useHrep If true , the polyhedra are returned in hrep, defaults to false Return Values poly A column vector of Polyhedron objects function reduction Scales a polyhedron by some factor around its barycenter. Usage scaled = util.reduction( poly , factor ) Parameters poly Any Polyhedron factor A scalar to scale poly by Return Values scaled A new Polyhedron function unit_vec Creates nth n -th unit vector of the canonical base in dimension dim . Usage u = util.unit_vec(dim, n) Parameters dim The dimension of the output vector n An integer in 1:dim Return value u A dim dimensional unit row vector, its only non zero component is th n -th","title":"<span class=\"code\"> <span class=\"mod\">module</span> util </span>"},{"location":"util/#module-util","text":"This modules contains internal functions that are not meant to be used by the end user.","title":" module util "},{"location":"util/#function-assert_shape","text":"Causes an error if size(x) is different from shape . Usage util.assert_shape(x, shape)","title":" function assert_shape "},{"location":"util/#function-barycenter","text":"Usage center = util.barycenter( poly ) Parameters poly Any bounded, non empty Polyhedron of dimension D Return Values center A D dimensional row vector representing the barycenter of poly","title":" function barycenter "},{"location":"util/#function-box","text":"Returns a hypercube of a given radius, potentially stretch vertically Usage poly = util.box(center, radius) poly = util.box(center, radius, z_size) Parameters Calculates the barycenter of a polyhedron : the average of all its vertices. center A row vector of dimension D radius A Scalar, he distance in each dimension from center to the edge of the cube z_size If given, overrides radius for the last dimension Return Values poly A D dimensional hypercube, stretched if z_size is different from radius","title":" function box "},{"location":"util/#function-is_near_unit","text":"Tests wether a vector is nearly colinear to any of the unit vectors of the canonical basis. The exact formula used is N(v/N(v) - u) <= epsilon where v is the tested vector, u the unit vector and N is the euclidian norm. Usage test = util.is_near_unit(vector) test = util.is_near_unit(vector, epsilon) Parameters vector Any row vector epsilon The error margin, defaults to 0.001","title":" function is_near_unit "},{"location":"util/#function-matrix_equals","text":"Tests wether two matrixes are equal within a given margin of error test = util.matrix_equals(A, B) test = util.matrix_equals(A, B, epsilon) Parameters A and B Two matrices to test epsilon The margin of error, defaults to 0.001","title":" function matrix_equals "},{"location":"util/#function-read_obj","text":"Reads a set of polyhedra from a .obj (blender) file. Usage poly = util.read_obj(file) poly = util.read_obj(file, useHRep) Parameters file The name of a file to load polyhedra from, relative to the cwd useHrep If true , the polyhedra are returned in hrep, defaults to false Return Values poly A column vector of Polyhedron objects","title":" function read_obj "},{"location":"util/#function-reduction","text":"Scales a polyhedron by some factor around its barycenter. Usage scaled = util.reduction( poly , factor ) Parameters poly Any Polyhedron factor A scalar to scale poly by Return Values scaled A new Polyhedron","title":" function reduction "},{"location":"util/#function-unit_vec","text":"Creates nth n -th unit vector of the canonical base in dimension dim . Usage u = util.unit_vec(dim, n) Parameters dim The dimension of the output vector n An integer in 1:dim Return value u A dim dimensional unit row vector, its only non zero component is th n -th","title":" function unit_vec "}]}